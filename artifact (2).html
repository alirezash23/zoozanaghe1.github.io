<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>تتریس مدرن</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
body {
margin: 0;
overflow: hidden;
background-color: #000;
color: #fff;
font-family: Arial, sans-serif;
}
#gameCanvas {
position: absolute;
top: 0;
left: 0;
}
#gameInfo {
position: absolute;
top: 10px;
right: 10px;
text-align: right;
}
#startButton, #recordButton {
position: absolute;
bottom: 20px;
padding: 10px 20px;
font-size: 16px;
background-color: #4CAF50;
color: white;
border: none;
cursor: pointer;
border-radius: 5px;
}
#startButton {
left: 20px;
}
#recordButton {
right: 20px;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="gameInfo">
<h2>امتیاز: <span id="score">0</span></h2>
<h3>سطح: <span id="level">1</span></h3>
</div>
<button id="startButton">شروع بازی</button>
<button id="recordButton">ثبت رکورد</button>

<script>
let scene, camera, renderer, grid, currentPiece, score, level, gameLoop, isGameOver;

const GRID_WIDTH = 10;
const GRID_HEIGHT = 20;
const CELL_SIZE = 1;

function init() {
scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 15;
camera.position.y = 10;
camera.lookAt(new THREE.Vector3(4.5, 10, 0));

renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

createGrid();
createLighting();

window.addEventListener('resize', onWindowResize, false);

document.addEventListener('keydown', onKeyDown);
document.getElementById('startButton').addEventListener('click', startGame);
document.getElementById('recordButton').addEventListener('click', saveRecord);
}

function createGrid() {
grid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
const gridGeometry = new THREE.BoxGeometry(GRID_WIDTH * CELL_SIZE, GRID_HEIGHT * CELL_SIZE, 0.1);
const gridMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.2 });
const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
gridMesh.position.set((GRID_WIDTH * CELL_SIZE) / 2 - 0.5, (GRID_HEIGHT * CELL_SIZE) / 2 - 0.5, -0.05);
scene.add(gridMesh);
}

function createLighting() {
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(10, 20, 10);
scene.add(directionalLight);
}

function createPiece() {
const shapes = [
[[1, 1, 1, 1]],
[[1, 1], [1, 1]],
[[1, 1, 1], [0, 1, 0]],
[[1, 1, 1], [1, 0, 0]],
[[1, 1, 1], [0, 0, 1]],
[[1, 1, 0], [0, 1, 1]],
[[0, 1, 1], [1, 1, 0]]
];

const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
currentPiece = {
shape: randomShape,
x: Math.floor(GRID_WIDTH / 2) - Math.floor(randomShape[0].length / 2),
y: GRID_HEIGHT
};

if (!canMovePiece(0, -1)) {
gameOver();
}
}

function drawPiece() {
currentPiece.mesh = new THREE.Group();
const material = new THREE.MeshPhongMaterial({ color: 0xffffff });

for (let y = 0; y < currentPiece.shape.length; y++) {
for (let x = 0; x < currentPiece.shape[y].length; x++) {
if (currentPiece.shape[y][x]) {
const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
const cube = new THREE.Mesh(geometry, material);
cube.position.set(
(currentPiece.x + x) * CELL_SIZE,
(currentPiece.y + y) * CELL_SIZE,
0
);
currentPiece.mesh.add(cube);
}
}
}

scene.add(currentPiece.mesh);
}

function canMovePiece(dx, dy) {
for (let y = 0; y < currentPiece.shape.length; y++) {
for (let x = 0; x < currentPiece.shape[y].length; x++) {
if (currentPiece.shape[y][x]) {
const newX = currentPiece.x + x + dx;
const newY = currentPiece.y + y + dy;
if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || (newY < GRID_HEIGHT && grid[newY][newX])) {
return false;
}
}
}
}
return true;
}

function movePiece(dx, dy) {
if (canMovePiece(dx, dy)) {
currentPiece.x += dx;
currentPiece.y += dy;
currentPiece.mesh.position.x += dx * CELL_SIZE;
currentPiece.mesh.position.y += dy * CELL_SIZE;
return true;
}
return false;
}

function rotatePiece() {
const rotated = currentPiece.shape[0].map((_, i) =>
currentPiece.shape.map(row => row[i]).reverse()
);

const originalShape = currentPiece.shape;
currentPiece.shape = rotated;

if (!canMovePiece(0, 0)) {
currentPiece.shape = originalShape;
return;
}

scene.remove(currentPiece.mesh);
drawPiece();
}

function mergePiece() {
for (let y = 0; y < currentPiece.shape.length; y++) {
for (let x = 0; x < currentPiece.shape[y].length; x++) {
if (currentPiece.shape[y][x]) {
grid[currentPiece.y + y][currentPiece.x + x] = 1;
}
}
}
}

function clearLines() {
let linesCleared = 0;
for (let y = GRID_HEIGHT - 1; y >= 0; y--) {
if (grid[y].every(cell => cell === 1)) {
grid.splice(y, 1);
grid.push(new Array(GRID_WIDTH).fill(0));
linesCleared++;
y++;
}
}
if (linesCleared > 0) {
score += linesCleared * 100 * level;
level = Math.floor(score / 1000) + 1;
updateScore();
redrawGrid();
}
}

function redrawGrid() {
scene.children.forEach(child => {
if (child instanceof THREE.Mesh && child !== currentPiece.mesh) {
scene.remove(child);
}
});

const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
for (let y = 0; y < GRID_HEIGHT; y++) {
for (let x = 0; x < GRID_WIDTH; x++) {
if (grid[y][x]) {
const geometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, CELL_SIZE);
const cube = new THREE.Mesh(geometry, material);
cube.position.set(x * CELL_SIZE, y * CELL_SIZE, 0);
scene.add(cube);
}
}
}
}

function updateScore() {
document.getElementById('score').textContent = score;
document.getElementById('level').textContent = level;
}

function gameOver() {
isGameOver = true;
clearInterval(gameLoop);
alert(`بازی تمام شد! امتیاز شما: ${score}`);
}

function update() {
if (!movePiece(0, -1)) {
mergePiece();
clearLines();
createPiece();
drawPiece();
}
}

function render() {
renderer.render(scene, camera);
}

function gameLoop() {
update();
render();
}

function startGame() {
if (gameLoop) clearInterval(gameLoop);
scene.children.length = 0;
createGrid();
createLighting();
grid = new Array(GRID_HEIGHT).fill().map(() => new Array(GRID_WIDTH).fill(0));
score = 0;
level = 1;
isGameOver = false;
updateScore();
createPiece();
drawPiece();
gameLoop = setInterval(() => {
if (!isGameOver) gameLoop();
}, 1000 / level);
}

function saveRecord() {
alert(`رکورد ${score} امتیاز ذخیره شد!`);
// اینجا می‌توانید کد مربوط به ذخیره رکورد در سرور را اضافه کنید
}

function onKeyDown(event) {
if (isGameOver) return;
switch (event.keyCode) {
case 37: // چپ
movePiece(-1, 0);
break;
case 39: // راست
movePiece(1, 0);
break;
case 40: // پایین
movePiece(0, -1);
break;
case 38: // بالا (چرخش)
rotatePiece();
break;
}
}

function onWindowResize() {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

init();
render();
</script>
</body>
</html>
